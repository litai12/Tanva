# 前端内存溢出 (Out of Memory) 隐患排查报告

本报告针对 Tanva 前端项目中可能导致浏览器崩溃或内存溢出的隐患进行了深度排查。主要风险集中在大量图像数据的内存存储、巨型组件的引用闭包以及重型资源的释放机制。

## 1. 核心高风险点：Base64 图像数据堆积 (Critical)
这是目前项目中最显著的内存风险点，极易导致单页内存突破 2GB 限制。

*   **隐患位置：** `frontend/src/stores/aiChatStore.ts` 和 `frontend/src/components/chat/AIChatDialog.tsx`
*   **问题描述：** 
    *   在 `AIChatDialog` 中，用户上传、粘贴或 AI 生成的图片，代码常使用 `FileReader.readAsDataURL` 转换为 Base64 字符串。
    *   这些巨大的字符串（单张 2-10MB）被直接存储在 `aiChatStore` 的 `messages` 数组中。
    *   **关键缺陷：** 前端 Store 缺乏对单会话消息数量（Max Message Limit）的硬性限制。随着聊天记录增加，内存占用呈线性增长。如果用户在同一个会话中进行大量生图或编辑操作，内存会迅速耗尽。
*   **修复建议：** 
    *   在 `aiChatStore` 中引入 `MAX_MESSAGES_PER_SESSION` 限制。
    *   历史消息中的图片应转换为缩略图存储，或者仅保留 URL 指向，避免内存持久化存储原始高清 Base64。

## 2. 渲染性能与 DOM 节点压力 (High)
*   **隐患位置：** `frontend/src/components/chat/AIChatDialog.tsx`
*   **问题描述：** 
    *   `AIChatDialog` 的历史消息列表（Content 区域）直接渲染所有 `messages`，未采用**虚拟化列表（Virtual List）**。
    *   当消息包含大量图片、视频预览和复杂的 Markdown 渲染时，浏览器需要维护数千个复杂的 DOM 节点。这不仅增加 JS 堆内存，还会导致严重的图层合成开销，造成滚动卡顿。
*   **修复建议：** 使用 `react-window` 或 `react-virtuoso` 对消息列表进行虚拟化重构，确保只渲染视口内的消息。

## 3. 3D 与 Canvas 资源释放不彻底 (High)
*   **隐患位置：** `frontend/src/components/flow/nodes/ThreeNode.tsx`, `frontend/src/components/canvas/GridRenderer.tsx`
*   **问题描述：**
    *   `ThreeNode.tsx` 涉及 Three.js 渲染。React 组件在卸载（Unmount）时，如果不手动显式调用 `renderer.dispose()`、`geometry.dispose()` 和 `material.dispose()`，WebGL 上下文和 GPU 内存将无法完全回收。
    *   `GridRenderer.tsx` 虽然实现了对象池，但在极端缩放级别下，生成的 Paper.js `Path` 对象仍可能瞬间激增，若清理回调未触发，会造成内存峰值。
*   **修复建议：** 
    *   严格排查所有 Three.js 组件的 `useEffect` 清理函数。
    *   确保 Paper.js 项目在切换或关闭时执行 `project.clear()` 或 `project.remove()`。

## 4. Blob URL 泄漏隐患 (Medium)
*   **隐患位置：** `Wan26Node.tsx`, `FlowOverlay.tsx`, `Sora2VideoNode.tsx` 等。
*   **问题描述：**
    *   项目中大量使用 `URL.createObjectURL(blob)`。目前的清理策略多为 `setTimeout(() => URL.revokeObjectURL(url), 2000)`。
    *   **风险：** 若组件在 2 秒内被销毁，或者用户快速操作产生大量临时 Blob，这种延迟清理机制容易失效，导致内存中残留大量未释放的原始数据块。
*   **修复建议：** 放弃 `setTimeout` 清理，改为在 `useEffect` 的 Cleanup 函数中立即执行 `revokeObjectURL`，或者使用引用计数管理。

## 5. 巨型组件与闭包引用 (Medium)
*   **隐患位置：** `AIChatDialog.tsx` (4600+行), `FlowOverlay.tsx` (6700+行)
*   **问题描述：**
    *   组件代码行数过多，内部混杂了大量的局部 State、Ref 和几十个 `useEffect`。
    *   在这种复杂度下，极其容易发生“内存逃逸”：即某些旧的事件监听器或闭包无意中捕获了巨大的局部变量（如大型数据对象），导致这些变量即使在业务逻辑上已失效，也无法被 GC 回收。
*   **修复建议：** 
    *   强制拆分 `AIChatDialog` 为更小的子组件（如 `MessageItem`, `InputArea`, `Header`）。
    *   将复杂的状态逻辑抽离到自定义 Hooks。

## 6. 监控系统重叠与浪费 (Low)
*   **隐患位置：** `frontend/src/utils/memoryMonitor.ts` 与 `improvedMemoryMonitor.ts`
*   **问题描述：**
    *   项目中并存两套内存监控逻辑，且各自运行 `setInterval`。
    *   `GridRenderer` 依赖旧版监控，而新版监控未覆盖全局。重复的统计和轮询对性能有微小损耗。
*   **修复建议：** 合并监控工具类，统一使用 `improvedMemoryMonitor` 并确保在全局入口启动。

## 7. Zustand 持久化与序列化开销 (Low)
*   **隐患位置：** `frontend/src/stores/aiChatStore.ts` (`persist` 中间件)
*   **问题描述：**
    *   Store 开启了持久化，每次更新消息列表（如流式输出时）都会触发 JSON 序列化。
    *   当 `messages` 包含 Base64 时，序列化过程极慢且会产生巨大的临时字符串，造成主线程卡顿和内存瞬间飙升。
*   **修复建议：** 使用 `partialize` 过滤掉不需持久化的大型字段，或者在写入存储前将大图片数据转移到 IndexedDB 的 Blob 字段中存储。

---

### 优先级建议
1.  **P0 (立即处理):** 限制 `aiChatStore` 消息数量，禁止在 Store 中长期存储原始高清 Base64。
2.  **P1 (重要):** 为 `AIChatDialog` 历史列表添加虚拟化滚动。
3.  **P1 (重要):** 完善 3D/Canvas 组件的销毁清理逻辑。
4.  **P2 (持续优化):** 拆分超大组件，规范化 Blob URL 管理。

