# 自动保存触发刷新与数据丢失问题分析报告

## 1. 现象描述
部分用户反映，在项目编辑过程中：
1. **自动保存触发刷新**：系统执行定时保存或防抖保存时，页面会突然自动刷新（或表现为闪烁后重新加载）。
2. **刷新后内容丢失**：刷新完成后，原本已编辑的内容（特别是图片或最新的矢量操作）消失，未能恢复。

---

## 2. 核心原因分析

### 2.1 为什么会自动刷新？

*   **内存溢出（OOM）导致浏览器崩溃重启**：
    大型项目执行 `paper.project.exportJSON()` 序列化时，如果画布包含大量高清图片或数万个路径点，会瞬间产生巨大的 JSON 字符串（甚至达到数百 MB）。这可能耗尽浏览器标签页内存，触发 OOM 崩溃。现代浏览器在崩溃后会自动尝试“重新加载”该页面。
*   **开发环境热更新（HMR）冲突**：
    在本地开发环境下，如果后端保存逻辑意外修改了前端 Vite 监听的公共资源或配置文件，会触发全页刷新。
*   **认证过期重定向**：
    若自动保存请求返回 401 且 `tokenRefreshManager` 刷新失败，前端可能会触发登录弹窗或状态重置。在某些环境下，登录状态异常可能被处理为页面刷新。

### 2.2 为什么刷新后文件会丢失？

*   **序列化时的元数据（Metadata）丢失**：
    这是最常见的原因。Paper.js 在执行 `exportJSON()` 时，如果 `Raster` 对象的 `data` 属性中没有显式记录 `imageId`，导出的 JSON 将只包含坐标而无资源链接。刷新后由于没有 ID，恢复逻辑（`restoreImageSources`）无法将 asset 与画布对象匹配，导致图片不显示。
*   **异步竞态（Race Condition）**：
    图片加载是异步的。如果 `raster.onLoad` 回调函数在保存操作执行的中途触发，并使用不完整的属性覆盖了 `raster.data`，保存的快照就会失效。
*   **浏览器存储配额超限**：
    系统会尝试将良好的快照备份到 `localStorage`（容量通常仅 5MB）。如果项目内容过大，备份会失败。若此时 IndexedDB（缓存层）也发生异常，刷新后将无法从本地缓存恢复，必须依赖 OSS，而 OSS 上的版本可能因为刚才的保存崩溃而并未更新。

---

## 3. 已实施与建议的解决方案

### 3.1 已实施的修复
*   **元数据强制标记**（见 `54f3720`）：在创建 `Raster` 时立即同步写入 `imageId` 等关键元数据，并在 `onLoad` 中使用合并策略（Spread Operator）更新尺寸，防止覆盖。
*   **保存节流与延迟**：在 `paperSaveService.ts` 中设置了 `SAVE_DELAY = 500ms` 和 `MIN_SAVE_INTERVAL = 2000ms`，合并高频触发，降低内存瞬间波动。

### 3.2 正在开启的调试手段
*   **开启保存事件监控**：取消 `App.tsx` 中 `SaveDebugPanel` 的注释，允许实时查看保存日志（`serialize`, `save_success`, `save_error`）。
*   **提升日志级别**：将全局日志级别设为 `debug`，记录保存过程中的每一个关键步骤。

---

## 4. 验证建议
1. 观察 `SaveDebugPanel` 中的 `paperJsonLen`。如果长度异常巨大（如超过 10MB），建议提醒用户拆分项目。
2. 在 `F12` 控制台查看 `[PaperSaveService]` 开头的日志，确认是否有 `imageId` 匹配失败的警告。
3. 检查 `localStorage` 中的 `tanva_last_good_snapshot_项目ID` 是否存在，作为数据丢失时的最后防线。
