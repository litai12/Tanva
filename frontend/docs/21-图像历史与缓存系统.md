# 图像历史与缓存系统

本篇介绍图像历史记录、AI 上下文图片缓存与智能放置策略。

## 组件与服务

- 历史服务：`src/services/imageHistoryService.ts`
  - `recordImageHistoryEntry()`：将 base64 先入历史，再后台上传至 OSS，成功后回填远程 URL
  - `migrateImageHistoryToRemote()`：批量迁移历史中仍为 base64 的项
- 历史 Store：`src/stores/imageHistoryStore.ts`（图片项、去重/更新/清空等）
- 上下文管理：`src/services/contextManager.ts`
  - 维护最近一次图片缓存（ID、中心点、提示词、最近模式）
  - 提供“是否为迭代操作”的判断与上下文 Prompt 构建
- 调试面板：`src/components/debug/CachedImageDebug.tsx`

## 并发与内存峰值控制

- 全局图片生成/转码限流：`src/utils/imageConcurrency.ts`（当前 `IMAGE_CONCURRENCY = 10`）
- 涉及 `canvas.toDataURL/toBlob`、`FileReader.readAsDataURL`、`Response.blob`、`createImageBitmap/WebCodecs` 等重操作时，优先使用该模块提供的封装（如 `canvasToDataUrl/canvasToBlob/blobToDataUrl/dataUrlToBlob/responseToBlob/createImageBitmapLimited`），避免批量并发导致瞬时内存峰值。
- 设计 JSON 规则：base64/dataURL/blob 仅允许运行时临时态；保存前必须上传并替换为远程 URL/OSS key（避免落库/外发）。

## 唯一远程引用（Canonical Ref）

为了避免同一张图在运行时出现多形态（`proxy?url` vs `proxy?key`、OSS 直链 URL vs `projects/...` key、是否带 host/斜杠等）导致重复下载/重复解码/重复纹理，前端统一收敛：

- 持久化层：只保存“可持久化远程引用”（优先 OSS `key/path`，其次远程 URL），并避免把 `/api/assets/proxy` 等运行时派生引用写入设计 JSON。
- 运行时展示：统一使用 `src/utils/imageSource.ts`：
  - `toCanonicalPersistableImageRef()`：将图片引用收敛到稳定唯一身份（去 proxy 包装、OSS 直链提取 key、去除 key 前导 `/` 等）
  - `toRenderableImageSrc()`：将 key/URL 转换为可渲染的 src（必要时走 `/api/assets/proxy` 解决 CORS）

## 解码缓存（ImageBitmap）

在需要频繁裁剪/缩放预览（如 Flow 节点预览、裁剪/切片预览）时，统一走 `src/services/imageResourceManager.ts`：

- `acquireImageBitmap(ref, { maxDimension, intrinsicWidth, intrinsicHeight })`：按需降采样解码并去重 in-flight
- `release()`：用完必须释放（引用计数归零后可被 LRU 淘汰并 `bitmap.close()`）
- 切换项目/离开编辑器时会清理该缓存，避免跨项目残留

## 智能放置策略（摘要）

- 基于最近缓存的中心点 `(cx, cy)` 与操作模式 `generate|edit|blend|analyze|chat`
- 新图像放置：
  - 生成（generate）：默认在缓存中心点右侧偏移约 522px
  - 编辑（edit）：默认在缓存中心点下方偏移约 522px
- 若无缓存中心点：回退到画布默认中心位置 `(0, 0)`

相关变更参见：`docs/06-变更日志.md`

## 与自动保存的关系

- 历史记录本身不强制触发保存，但图片作为画布对象/层变化被收敛到项目内容中
- 切换项目时默认不清理历史，以便跨文件查看；如需隔离可在切换时清空

## 最佳实践

- 在批量生成或频繁编辑时，定期迁移 base64 → 远程 URL，减少本地内存
- 对关键图像使用清晰的 `title` 与分目录 `dir` 便于归档
